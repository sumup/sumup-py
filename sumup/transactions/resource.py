# Code generated by `py-sdk-gen`. DO NOT EDIT.
from .._service import Resource, AsyncResource, HeaderTypes
from .._exceptions import APIError
from .types import (
    Link,
    TransactionFull,
    TransactionHistory,
)
import datetime
import httpx
import typing
import pydantic
import typing_extensions


class RefundTransactionBody(pydantic.BaseModel):
    """
    Optional amount for partial refunds of transactions.
    """

    amount: typing.Optional[float] = None
    """
	Amount to be refunded. Eligible amount can't exceed the amount of the transaction and varies based on countryand currency. If you do not specify a value, the system performs a full refund of the transaction.
	"""


class GetTransactionV21Params(pydantic.BaseModel):
    """
    GetTransactionV21Params: query parameters for GetTransactionV2.1
    """

    client_transaction_id: typing.Optional[str] = None

    foreign_transaction_id: typing.Optional[str] = None

    id: typing.Optional[str] = None

    internal_id: typing.Optional[str] = None

    transaction_code: typing.Optional[str] = None


class GetTransactionParams(pydantic.BaseModel):
    """
    GetTransactionParams: query parameters for GetTransaction
    """

    id: typing.Optional[str] = None

    internal_id: typing.Optional[str] = None

    transaction_code: typing.Optional[str] = None


class ListTransactionsV21Params(pydantic.BaseModel):
    """
    ListTransactionsV21Params: query parameters for ListTransactionsV2.1
    """

    changes_since: typing.Optional[datetime.datetime] = None

    limit: typing.Optional[int] = None

    newest_ref: typing.Optional[str] = None

    newest_time: typing.Optional[datetime.datetime] = None

    oldest_ref: typing.Optional[str] = None

    oldest_time: typing.Optional[datetime.datetime] = None

    order: typing.Optional[str] = None

    payment_types: typing.Optional[list[str]] = None

    statuses: typing.Optional[list[str]] = None

    transaction_code: typing.Optional[str] = None

    types: typing.Optional[list[str]] = None

    users: typing.Optional[list[str]] = None


class ListTransactionsParams(pydantic.BaseModel):
    """
    ListTransactionsParams: query parameters for ListTransactions
    """

    changes_since: typing.Optional[datetime.datetime] = None

    limit: typing.Optional[int] = None

    newest_ref: typing.Optional[str] = None

    newest_time: typing.Optional[datetime.datetime] = None

    oldest_ref: typing.Optional[str] = None

    oldest_time: typing.Optional[datetime.datetime] = None

    order: typing.Optional[str] = None

    payment_types: typing.Optional[list[str]] = None

    statuses: typing.Optional[list[str]] = None

    transaction_code: typing.Optional[str] = None

    types: typing.Optional[list[str]] = None

    users: typing.Optional[list[str]] = None


class ListTransactionsV21200Response(pydantic.BaseModel):
    """
    ListTransactionsV21200Response is a schema definition.
    """

    items: typing.Optional[list[TransactionHistory]] = None

    links: typing.Optional[list[Link]] = None


class ListTransactions200Response(pydantic.BaseModel):
    """
    ListTransactions200Response is a schema definition.
    """

    items: typing.Optional[list[TransactionHistory]] = None

    links: typing.Optional[list[Link]] = None


class TransactionsResource(Resource):
    def __init__(self, client: httpx.Client):
        super().__init__(client)

    def refund(
        self, txn_id: str, body: RefundTransactionBody, headers: typing.Optional[HeaderTypes] = None
    ):
        """
        Refund a transaction

        Refunds an identified transaction either in full or partially.
        """
        resp = self._client.post(
            f"/v0.1/me/refund/{txn_id}",
            json=body.model_dump(),
            headers=headers,
        )
        if resp.status_code == 204:
            return
        elif resp.status_code == 404:
            raise APIError("Not Found", status=resp.status_code, body=resp.text)
        elif resp.status_code == 409:
            raise APIError("Conflict", status=resp.status_code, body=resp.text)
        else:
            raise APIError("Unexpected response", status=resp.status_code, body=resp.text)

    def get(
        self,
        merchant_code: str,
        params: typing.Optional[GetTransactionV21Params] = None,
        headers: typing.Optional[HeaderTypes] = None,
    ) -> TransactionFull:
        """
        Retrieve a transaction

        Retrieves the full details of an identified transaction. The transaction resource is identified by a query parameter and*one* of following parameters is required:

         *  `id`
         *  `internal_id`
         *  `transaction_code`
         *  `foreign_transaction_id`
         *  `client_transaction_id`
        """
        resp = self._client.get(
            f"/v2.1/merchants/{merchant_code}/transactions",
            params=params.model_dump() if params else None,
            headers=headers,
        )
        if resp.status_code == 200:
            return pydantic.TypeAdapter(TransactionFull).validate_python(resp.json())
        elif resp.status_code == 401:
            raise APIError("Unauthorized", status=resp.status_code, body=resp.text)
        elif resp.status_code == 404:
            raise APIError("Not Found", status=resp.status_code, body=resp.text)
        else:
            raise APIError("Unexpected response", status=resp.status_code, body=resp.text)

    @typing_extensions.deprecated("This method is deprecated")
    def get_deprecated(
        self,
        params: typing.Optional[GetTransactionParams] = None,
        headers: typing.Optional[HeaderTypes] = None,
    ) -> TransactionFull:
        """
        Retrieve a transaction

        Retrieves the full details of an identified transaction. The transaction resource is identified by a query parameter and*one* of following parameters is required:

         *  `id`
         *  `internal_id`
         *  `transaction_code`
         *  `foreign_transaction_id`
         *  `client_transaction_id`
        """
        resp = self._client.get(
            "/v0.1/me/transactions",
            params=params.model_dump() if params else None,
            headers=headers,
        )
        if resp.status_code == 200:
            return pydantic.TypeAdapter(TransactionFull).validate_python(resp.json())
        elif resp.status_code == 401:
            raise APIError("Unauthorized", status=resp.status_code, body=resp.text)
        elif resp.status_code == 404:
            raise APIError("Not Found", status=resp.status_code, body=resp.text)
        else:
            raise APIError("Unexpected response", status=resp.status_code, body=resp.text)

    def list(
        self,
        merchant_code: str,
        params: typing.Optional[ListTransactionsV21Params] = None,
        headers: typing.Optional[HeaderTypes] = None,
    ) -> ListTransactionsV21200Response:
        """
        List transactions

        Lists detailed history of all transactions associated with the merchant profile.
        """
        resp = self._client.get(
            f"/v2.1/merchants/{merchant_code}/transactions/history",
            params=params.model_dump() if params else None,
            headers=headers,
        )
        if resp.status_code == 200:
            return pydantic.TypeAdapter(ListTransactionsV21200Response).validate_python(resp.json())
        elif resp.status_code == 401:
            raise APIError("Unauthorized", status=resp.status_code, body=resp.text)
        else:
            raise APIError("Unexpected response", status=resp.status_code, body=resp.text)

    @typing_extensions.deprecated("This method is deprecated")
    def list_deprecated(
        self,
        params: typing.Optional[ListTransactionsParams] = None,
        headers: typing.Optional[HeaderTypes] = None,
    ) -> ListTransactions200Response:
        """
        List transactions

        Lists detailed history of all transactions associated with the merchant profile.
        """
        resp = self._client.get(
            "/v0.1/me/transactions/history",
            params=params.model_dump() if params else None,
            headers=headers,
        )
        if resp.status_code == 200:
            return pydantic.TypeAdapter(ListTransactions200Response).validate_python(resp.json())
        elif resp.status_code == 401:
            raise APIError("Unauthorized", status=resp.status_code, body=resp.text)
        else:
            raise APIError("Unexpected response", status=resp.status_code, body=resp.text)


class AsyncTransactionsResource(AsyncResource):
    def __init__(self, client: httpx.AsyncClient):
        super().__init__(client)

    async def refund(
        self, txn_id: str, body: RefundTransactionBody, headers: typing.Optional[HeaderTypes] = None
    ):
        """
        Refund a transaction

        Refunds an identified transaction either in full or partially.
        """
        resp = await self._client.post(
            f"/v0.1/me/refund/{txn_id}",
            json=body.model_dump(),
            headers=headers,
        )
        if resp.status_code == 204:
            return
        elif resp.status_code == 404:
            raise APIError("Not Found", status=resp.status_code, body=resp.text)
        elif resp.status_code == 409:
            raise APIError("Conflict", status=resp.status_code, body=resp.text)
        else:
            raise APIError("Unexpected response", status=resp.status_code, body=resp.text)

    async def get(
        self,
        merchant_code: str,
        params: typing.Optional[GetTransactionV21Params] = None,
        headers: typing.Optional[HeaderTypes] = None,
    ) -> TransactionFull:
        """
        Retrieve a transaction

        Retrieves the full details of an identified transaction. The transaction resource is identified by a query parameter and*one* of following parameters is required:

         *  `id`
         *  `internal_id`
         *  `transaction_code`
         *  `foreign_transaction_id`
         *  `client_transaction_id`
        """
        resp = await self._client.get(
            f"/v2.1/merchants/{merchant_code}/transactions",
            params=params.model_dump() if params else None,
            headers=headers,
        )
        if resp.status_code == 200:
            return pydantic.TypeAdapter(TransactionFull).validate_python(resp.json())
        elif resp.status_code == 401:
            raise APIError("Unauthorized", status=resp.status_code, body=resp.text)
        elif resp.status_code == 404:
            raise APIError("Not Found", status=resp.status_code, body=resp.text)
        else:
            raise APIError("Unexpected response", status=resp.status_code, body=resp.text)

    @typing_extensions.deprecated("This method is deprecated")
    async def get_deprecated(
        self,
        params: typing.Optional[GetTransactionParams] = None,
        headers: typing.Optional[HeaderTypes] = None,
    ) -> TransactionFull:
        """
        Retrieve a transaction

        Retrieves the full details of an identified transaction. The transaction resource is identified by a query parameter and*one* of following parameters is required:

         *  `id`
         *  `internal_id`
         *  `transaction_code`
         *  `foreign_transaction_id`
         *  `client_transaction_id`
        """
        resp = await self._client.get(
            "/v0.1/me/transactions",
            params=params.model_dump() if params else None,
            headers=headers,
        )
        if resp.status_code == 200:
            return pydantic.TypeAdapter(TransactionFull).validate_python(resp.json())
        elif resp.status_code == 401:
            raise APIError("Unauthorized", status=resp.status_code, body=resp.text)
        elif resp.status_code == 404:
            raise APIError("Not Found", status=resp.status_code, body=resp.text)
        else:
            raise APIError("Unexpected response", status=resp.status_code, body=resp.text)

    async def list(
        self,
        merchant_code: str,
        params: typing.Optional[ListTransactionsV21Params] = None,
        headers: typing.Optional[HeaderTypes] = None,
    ) -> ListTransactionsV21200Response:
        """
        List transactions

        Lists detailed history of all transactions associated with the merchant profile.
        """
        resp = await self._client.get(
            f"/v2.1/merchants/{merchant_code}/transactions/history",
            params=params.model_dump() if params else None,
            headers=headers,
        )
        if resp.status_code == 200:
            return pydantic.TypeAdapter(ListTransactionsV21200Response).validate_python(resp.json())
        elif resp.status_code == 401:
            raise APIError("Unauthorized", status=resp.status_code, body=resp.text)
        else:
            raise APIError("Unexpected response", status=resp.status_code, body=resp.text)

    @typing_extensions.deprecated("This method is deprecated")
    async def list_deprecated(
        self,
        params: typing.Optional[ListTransactionsParams] = None,
        headers: typing.Optional[HeaderTypes] = None,
    ) -> ListTransactions200Response:
        """
        List transactions

        Lists detailed history of all transactions associated with the merchant profile.
        """
        resp = await self._client.get(
            "/v0.1/me/transactions/history",
            params=params.model_dump() if params else None,
            headers=headers,
        )
        if resp.status_code == 200:
            return pydantic.TypeAdapter(ListTransactions200Response).validate_python(resp.json())
        elif resp.status_code == 401:
            raise APIError("Unauthorized", status=resp.status_code, body=resp.text)
        else:
            raise APIError("Unexpected response", status=resp.status_code, body=resp.text)
