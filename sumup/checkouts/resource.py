# Code generated by `py-sdk-gen`. DO NOT EDIT.
from .._service import Resource, AsyncResource, HeaderTypes
from .._exceptions import APIError
from .types import (
    Card,
    Checkout,
    CheckoutAccepted,
    CheckoutSuccess,
    Currency,
    EntryMode,
    MandatePayload,
    PaymentType,
    PersonalDetails,
)
import datetime
import httpx
import typing
import pydantic

CreateCheckoutBodyPurpose = typing.Literal["CHECKOUT", "SETUP_RECURRING_PAYMENT"]

CreateCheckoutBodyStatus = typing.Literal["FAILED", "PAID", "PENDING"]

CreateCheckoutBodyTransactionStatus = typing.Literal["CANCELLED", "FAILED", "PENDING", "SUCCESSFUL"]


class CreateCheckoutBodyTransaction(pydantic.BaseModel):
    """
    CreateCheckoutBodyTransaction is a schema definition.
    """

    amount: typing.Optional[float] = None
    """
	Total amount of the transaction.
	"""

    auth_code: typing.Optional[str] = None
    """
	Authorization code for the transaction sent by the payment card issuer or bank. Applicable only to card payments.
	"""

    currency: typing.Optional[Currency] = None
    """
	Three-letter [ISO4217](https://en.wikipedia.org/wiki/ISO_4217) code of the currency for the amount. Currently supportedcurrency values are enumerated above.
	"""

    entry_mode: typing.Optional[EntryMode] = None
    """
	Entry mode of the payment details.
	"""

    id: typing.Optional[str] = None
    """
	Unique ID of the transaction.
	"""

    installments_count: typing.Optional[int] = None
    """
	Current number of the installment for deferred payments.
	Min: 1
	"""

    internal_id: typing.Optional[int] = None
    """
	Internal unique ID of the transaction on the SumUp platform.
	Format: int64
	"""

    merchant_code: typing.Optional[str] = None
    """
	Unique code of the registered merchant to whom the payment is made.
	"""

    payment_type: typing.Optional[PaymentType] = None
    """
	Payment type used for the transaction.
	"""

    status: typing.Optional[CreateCheckoutBodyTransactionStatus] = None
    """
	Current status of the transaction.
	"""

    timestamp: typing.Optional[datetime.datetime] = None
    """
	Date and time of the creation of the transaction. Response format expressed according to [ISO8601](https://en.wikipedia.org/wiki/ISO_8601) code.
	"""

    tip_amount: typing.Optional[float] = None
    """
	Amount of the tip (out of the total transaction amount).
	"""

    transaction_code: typing.Optional[str] = None
    """
	Transaction code returned by the acquirer/processing entity after processing the transaction.
	"""

    vat_amount: typing.Optional[float] = None
    """
	Amount of the applicable VAT (out of the total transaction amount).
	"""


class CreateCheckoutBody(pydantic.BaseModel):
    """
    Details of the payment checkout.
    """

    amount: float
    """
	Amount of the payment.
	"""

    checkout_reference: str
    """
	Unique ID of the payment checkout specified by the client application when creating the checkout resource.
	Max length: 90
	"""

    currency: Currency
    """
	Three-letter [ISO4217](https://en.wikipedia.org/wiki/ISO_4217) code of the currency for the amount. Currently supportedcurrency values are enumerated above.
	"""

    merchant_code: str
    """
	Unique identifying code of the merchant profile.
	"""

    customer_id: typing.Optional[str] = None
    """
	Unique identification of a customer. If specified, the checkout session and payment instrument are associated withthe referenced customer.
	"""

    date: typing.Optional[datetime.datetime] = None
    """
	Date and time of the creation of the payment checkout. Response format expressed according to [ISO8601](https://en.wikipedia.org/wiki/ISO_8601) code.
	Readonly
	"""

    description: typing.Optional[str] = None
    """
	Short description of the checkout visible in the SumUp dashboard. The description can contribute to reporting, allowingeasier identification of a checkout.
	"""

    id: typing.Optional[str] = None
    """
	Unique ID of the checkout resource.
	Read only
	"""

    purpose: typing.Optional[CreateCheckoutBodyPurpose] = None
    """
	Purpose of the checkout.
	Default: "CHECKOUT"
	"""

    redirect_url: typing.Optional[str] = None
    """
	__Required__ for [APMs](https://developer.sumup.com/online-payments/apm/introduction) and __recommended__ forcard payments. Refers to a url where the end user is redirected once the payment processing completes. Ifnot specified, the [Payment Widget](https://developer.sumup.com/online-payments/tools/card-widget) renders [3DSchallenge](https://developer.sumup.com/online-payments/features/3ds) within an iframe instead of performing afull-page redirect.
	"""

    return_url: typing.Optional[str] = None
    """
	URL to which the SumUp platform sends the processing status of the payment checkout.
	Format: uri
	"""

    status: typing.Optional[CreateCheckoutBodyStatus] = None
    """
	Current status of the checkout.
	Read only
	"""

    transactions: typing.Optional[list[CreateCheckoutBodyTransaction]] = None
    """
	List of transactions related to the payment.
	Read only
	Unique items only
	"""

    valid_until: typing.Optional[datetime.datetime] = None
    """
	Date and time of the checkout expiration before which the client application needs to send a processing request.If no value is present, the checkout does not have an expiration time.
	"""


ProcessCheckoutBodyPaymentType = typing.Literal["bancontact", "blik", "boleto", "card", "ideal"]


class ProcessCheckoutBody(pydantic.BaseModel):
    """
    Details of the payment instrument for processing the checkout.
    """

    payment_type: ProcessCheckoutBodyPaymentType
    """
	Describes the payment method used to attempt processing
	"""

    card: typing.Optional[Card] = None
    """
	__Required when payment type is `card`.__ Details of the payment card.
	"""

    customer_id: typing.Optional[str] = None
    """
	__Required when `token` is provided.__ Unique ID of the customer.
	"""

    installments: typing.Optional[int] = None
    """
	Number of installments for deferred payments. Available only to merchant users in Brazil.
	Min: 1
	Max: 12
	"""

    mandate: typing.Optional[MandatePayload] = None
    """
	Mandate is passed when a card is to be tokenized
	"""

    personal_details: typing.Optional[PersonalDetails] = None
    """
	Personal details for the customer.
	"""

    token: typing.Optional[str] = None
    """
	__Required when using a tokenized card to process a checkout.__ Unique token identifying the saved payment cardfor a customer.
	"""


class GetPaymentMethodsParams(pydantic.BaseModel):
    """
    GetPaymentMethodsParams: query parameters for GetPaymentMethods
    """

    amount: typing.Optional[float] = None

    currency: typing.Optional[str] = None


class ListCheckoutsParams(pydantic.BaseModel):
    """
    ListCheckoutsParams: query parameters for ListCheckouts
    """

    checkout_reference: typing.Optional[str] = None


class GetPaymentMethods200ResponseAvailablePaymentMethod(pydantic.BaseModel):
    """
    GetPaymentMethods200ResponseAvailablePaymentMethod is a schema definition.
    """

    id: str
    """
	The ID of the payment method.
	"""


class GetPaymentMethods200Response(pydantic.BaseModel):
    """
    GetPaymentMethods200Response is a schema definition.
    """

    available_payment_methods: typing.Optional[
        list[GetPaymentMethods200ResponseAvailablePaymentMethod]
    ] = None


ListCheckouts200Response = list[CheckoutSuccess]
"""
ListCheckouts200Response is a schema definition.
"""

ProcessCheckoutResponse = typing.Union[CheckoutSuccess, CheckoutAccepted]


class CheckoutsResource(Resource):
    def __init__(self, client: httpx.Client):
        super().__init__(client)

    def list_available_payment_methods(
        self,
        merchant_code: str,
        params: typing.Optional[GetPaymentMethodsParams] = None,
        headers: typing.Optional[HeaderTypes] = None,
    ) -> GetPaymentMethods200Response:
        """
        Get available payment methods

        Get payment methods available for the given merchant to use with a checkout.
        """
        resp = self._client.get(
            f"/v0.1/merchants/{merchant_code}/payment-methods",
            params=params.model_dump(by_alias=True, exclude_none=True) if params else None,
            headers=headers,
        )
        if resp.status_code == 200:
            return pydantic.TypeAdapter(GetPaymentMethods200Response).validate_python(resp.json())
        elif resp.status_code == 400:
            raise APIError("Bad Request", status=resp.status_code, body=resp.text)
        elif resp.status_code == 401:
            raise APIError("Unauthorized", status=resp.status_code, body=resp.text)
        else:
            raise APIError("Unexpected response", status=resp.status_code, body=resp.text)

    def create(
        self, body: CreateCheckoutBody, headers: typing.Optional[HeaderTypes] = None
    ) -> Checkout:
        """
        Create a checkout

        Creates a new payment checkout resource. The unique `checkout_reference` created by this request, is used for furthermanipulation of the checkout.

        For 3DS checkouts, add the `redirect_url` parameter to your request body schema.

        Follow by processing a checkout to charge the provided payment instrument.
        """
        resp = self._client.post(
            "/v0.1/checkouts",
            json=body.model_dump(exclude_unset=True),
            headers=headers,
        )
        if resp.status_code == 201:
            return pydantic.TypeAdapter(Checkout).validate_python(resp.json())
        elif resp.status_code == 400:
            raise APIError("Bad Request", status=resp.status_code, body=resp.text)
        elif resp.status_code == 401:
            raise APIError("Unauthorized", status=resp.status_code, body=resp.text)
        elif resp.status_code == 403:
            raise APIError("Forbidden", status=resp.status_code, body=resp.text)
        elif resp.status_code == 409:
            raise APIError("Conflict", status=resp.status_code, body=resp.text)
        else:
            raise APIError("Unexpected response", status=resp.status_code, body=resp.text)

    def list(
        self,
        params: typing.Optional[ListCheckoutsParams] = None,
        headers: typing.Optional[HeaderTypes] = None,
    ) -> ListCheckouts200Response:
        """
        List checkouts

        Lists created checkout resources according to the applied `checkout_reference`.
        """
        resp = self._client.get(
            "/v0.1/checkouts",
            params=params.model_dump(by_alias=True, exclude_none=True) if params else None,
            headers=headers,
        )
        if resp.status_code == 200:
            return pydantic.TypeAdapter(ListCheckouts200Response).validate_python(resp.json())
        elif resp.status_code == 401:
            raise APIError("Unauthorized", status=resp.status_code, body=resp.text)
        else:
            raise APIError("Unexpected response", status=resp.status_code, body=resp.text)

    def get(self, id: str, headers: typing.Optional[HeaderTypes] = None) -> CheckoutSuccess:
        """
        Retrieve a checkout

        Retrieves an identified checkout resource. Use this request after processing a checkout to confirm its status and informthe end user respectively.
        """
        resp = self._client.get(
            f"/v0.1/checkouts/{id}",
            headers=headers,
        )
        if resp.status_code == 200:
            return pydantic.TypeAdapter(CheckoutSuccess).validate_python(resp.json())
        elif resp.status_code == 401:
            raise APIError("Unauthorized", status=resp.status_code, body=resp.text)
        elif resp.status_code == 404:
            raise APIError("Not Found", status=resp.status_code, body=resp.text)
        else:
            raise APIError("Unexpected response", status=resp.status_code, body=resp.text)

    def process(
        self, id: str, body: ProcessCheckoutBody, headers: typing.Optional[HeaderTypes] = None
    ) -> ProcessCheckoutResponse:
        """
        Process a checkout

        Processing a checkout will attempt to charge the provided payment instrument for the amount of the specified checkout resourceinitiated in the `Create a checkout` endpoint.

        Follow this request with `Retrieve a checkout` to confirm its status.
        """
        resp = self._client.put(
            f"/v0.1/checkouts/{id}",
            json=body.model_dump(exclude_unset=True),
            headers=headers,
        )
        if resp.status_code == 200:
            return pydantic.TypeAdapter(CheckoutSuccess).validate_python(resp.json())
        elif resp.status_code == 202:
            return pydantic.TypeAdapter(CheckoutAccepted).validate_python(resp.json())
        elif resp.status_code == 400:
            raise APIError("Bad Request", status=resp.status_code, body=resp.text)
        elif resp.status_code == 401:
            raise APIError("Unauthorized", status=resp.status_code, body=resp.text)
        elif resp.status_code == 404:
            raise APIError("Not Found", status=resp.status_code, body=resp.text)
        elif resp.status_code == 409:
            raise APIError("Conflict", status=resp.status_code, body=resp.text)
        else:
            raise APIError("Unexpected response", status=resp.status_code, body=resp.text)

    def deactivate(self, id: str, headers: typing.Optional[HeaderTypes] = None) -> Checkout:
        """
        Deactivate a checkout

        Deactivates an identified checkout resource. If the checkout has already been processed it can not be deactivated.
        """
        resp = self._client.delete(
            f"/v0.1/checkouts/{id}",
            headers=headers,
        )
        if resp.status_code == 200:
            return pydantic.TypeAdapter(Checkout).validate_python(resp.json())
        elif resp.status_code == 401:
            raise APIError("Unauthorized", status=resp.status_code, body=resp.text)
        elif resp.status_code == 404:
            raise APIError("Not Found", status=resp.status_code, body=resp.text)
        elif resp.status_code == 409:
            raise APIError("Conflict", status=resp.status_code, body=resp.text)
        else:
            raise APIError("Unexpected response", status=resp.status_code, body=resp.text)


class AsyncCheckoutsResource(AsyncResource):
    def __init__(self, client: httpx.AsyncClient):
        super().__init__(client)

    async def list_available_payment_methods(
        self,
        merchant_code: str,
        params: typing.Optional[GetPaymentMethodsParams] = None,
        headers: typing.Optional[HeaderTypes] = None,
    ) -> GetPaymentMethods200Response:
        """
        Get available payment methods

        Get payment methods available for the given merchant to use with a checkout.
        """
        resp = await self._client.get(
            f"/v0.1/merchants/{merchant_code}/payment-methods",
            params=params.model_dump(by_alias=True, exclude_none=True) if params else None,
            headers=headers,
        )
        if resp.status_code == 200:
            return pydantic.TypeAdapter(GetPaymentMethods200Response).validate_python(resp.json())
        elif resp.status_code == 400:
            raise APIError("Bad Request", status=resp.status_code, body=resp.text)
        elif resp.status_code == 401:
            raise APIError("Unauthorized", status=resp.status_code, body=resp.text)
        else:
            raise APIError("Unexpected response", status=resp.status_code, body=resp.text)

    async def create(
        self, body: CreateCheckoutBody, headers: typing.Optional[HeaderTypes] = None
    ) -> Checkout:
        """
        Create a checkout

        Creates a new payment checkout resource. The unique `checkout_reference` created by this request, is used for furthermanipulation of the checkout.

        For 3DS checkouts, add the `redirect_url` parameter to your request body schema.

        Follow by processing a checkout to charge the provided payment instrument.
        """
        resp = await self._client.post(
            "/v0.1/checkouts",
            json=body.model_dump(exclude_unset=True),
            headers=headers,
        )
        if resp.status_code == 201:
            return pydantic.TypeAdapter(Checkout).validate_python(resp.json())
        elif resp.status_code == 400:
            raise APIError("Bad Request", status=resp.status_code, body=resp.text)
        elif resp.status_code == 401:
            raise APIError("Unauthorized", status=resp.status_code, body=resp.text)
        elif resp.status_code == 403:
            raise APIError("Forbidden", status=resp.status_code, body=resp.text)
        elif resp.status_code == 409:
            raise APIError("Conflict", status=resp.status_code, body=resp.text)
        else:
            raise APIError("Unexpected response", status=resp.status_code, body=resp.text)

    async def list(
        self,
        params: typing.Optional[ListCheckoutsParams] = None,
        headers: typing.Optional[HeaderTypes] = None,
    ) -> ListCheckouts200Response:
        """
        List checkouts

        Lists created checkout resources according to the applied `checkout_reference`.
        """
        resp = await self._client.get(
            "/v0.1/checkouts",
            params=params.model_dump(by_alias=True, exclude_none=True) if params else None,
            headers=headers,
        )
        if resp.status_code == 200:
            return pydantic.TypeAdapter(ListCheckouts200Response).validate_python(resp.json())
        elif resp.status_code == 401:
            raise APIError("Unauthorized", status=resp.status_code, body=resp.text)
        else:
            raise APIError("Unexpected response", status=resp.status_code, body=resp.text)

    async def get(self, id: str, headers: typing.Optional[HeaderTypes] = None) -> CheckoutSuccess:
        """
        Retrieve a checkout

        Retrieves an identified checkout resource. Use this request after processing a checkout to confirm its status and informthe end user respectively.
        """
        resp = await self._client.get(
            f"/v0.1/checkouts/{id}",
            headers=headers,
        )
        if resp.status_code == 200:
            return pydantic.TypeAdapter(CheckoutSuccess).validate_python(resp.json())
        elif resp.status_code == 401:
            raise APIError("Unauthorized", status=resp.status_code, body=resp.text)
        elif resp.status_code == 404:
            raise APIError("Not Found", status=resp.status_code, body=resp.text)
        else:
            raise APIError("Unexpected response", status=resp.status_code, body=resp.text)

    async def process(
        self, id: str, body: ProcessCheckoutBody, headers: typing.Optional[HeaderTypes] = None
    ) -> ProcessCheckoutResponse:
        """
        Process a checkout

        Processing a checkout will attempt to charge the provided payment instrument for the amount of the specified checkout resourceinitiated in the `Create a checkout` endpoint.

        Follow this request with `Retrieve a checkout` to confirm its status.
        """
        resp = await self._client.put(
            f"/v0.1/checkouts/{id}",
            json=body.model_dump(exclude_unset=True),
            headers=headers,
        )
        if resp.status_code == 200:
            return pydantic.TypeAdapter(CheckoutSuccess).validate_python(resp.json())
        elif resp.status_code == 202:
            return pydantic.TypeAdapter(CheckoutAccepted).validate_python(resp.json())
        elif resp.status_code == 400:
            raise APIError("Bad Request", status=resp.status_code, body=resp.text)
        elif resp.status_code == 401:
            raise APIError("Unauthorized", status=resp.status_code, body=resp.text)
        elif resp.status_code == 404:
            raise APIError("Not Found", status=resp.status_code, body=resp.text)
        elif resp.status_code == 409:
            raise APIError("Conflict", status=resp.status_code, body=resp.text)
        else:
            raise APIError("Unexpected response", status=resp.status_code, body=resp.text)

    async def deactivate(self, id: str, headers: typing.Optional[HeaderTypes] = None) -> Checkout:
        """
        Deactivate a checkout

        Deactivates an identified checkout resource. If the checkout has already been processed it can not be deactivated.
        """
        resp = await self._client.delete(
            f"/v0.1/checkouts/{id}",
            headers=headers,
        )
        if resp.status_code == 200:
            return pydantic.TypeAdapter(Checkout).validate_python(resp.json())
        elif resp.status_code == 401:
            raise APIError("Unauthorized", status=resp.status_code, body=resp.text)
        elif resp.status_code == 404:
            raise APIError("Not Found", status=resp.status_code, body=resp.text)
        elif resp.status_code == 409:
            raise APIError("Conflict", status=resp.status_code, body=resp.text)
        else:
            raise APIError("Unexpected response", status=resp.status_code, body=resp.text)
