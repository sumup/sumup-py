# Code generated by `py-sdk-gen`. DO NOT EDIT.
from .._service import Resource, AsyncResource, HeaderTypes
from .._exceptions import APIError
from .types import (
    CreateReaderCheckoutResponse,
    Meta,
    Reader,
    ReaderId,
    ReaderName,
    ReaderPairingCode,
)
import httpx
import typing
import pydantic


class CreateReaderBody(pydantic.BaseModel):
    """
    CreateReaderBody is a schema definition.
    """

    name: ReaderName
    """
	Custom human-readable, user-defined name for easier identification of the reader.
	Max length: 500
	"""

    pairing_code: ReaderPairingCode
    """
	The pairing code is a 8 or 9 character alphanumeric string that is displayed on a SumUp Device after initiatingthe pairing. It is used to link the physical device to the created pairing.
	Min length: 8
	Max length: 9
	"""

    meta: typing.Optional[Meta] = None
    """
	A set of key-value pairs that you can attach to an object. This can be useful for storing additional informationabout the object in a structured format.
	
	**Warning**: Updating Meta will overwrite the existing data. Make sure to always include the complete JSON object.
	"""


class UpdateReaderBody(pydantic.BaseModel):
    """
    UpdateReaderBody is a schema definition.
    """

    meta: typing.Optional[Meta] = None
    """
	A set of key-value pairs that you can attach to an object. This can be useful for storing additional informationabout the object in a structured format.
	
	**Warning**: Updating Meta will overwrite the existing data. Make sure to always include the complete JSON object.
	"""

    name: typing.Optional[ReaderName] = None
    """
	Custom human-readable, user-defined name for easier identification of the reader.
	Max length: 500
	"""


CreateReaderCheckoutBodyAffiliateTags = dict[typing.Any, typing.Any]
"""
Additional metadata for the transaction.
It is key-value object that can be associated with the transaction.
"""


class CreateReaderCheckoutBodyAffiliate(pydantic.BaseModel):
    """
            Affiliate metadata for the transaction.
    It is a field that allow for integrators to track the source of the transaction.
    """

    app_id: str
    """
	Application ID of the affiliate.
	It is a unique identifier for the application and should be set by the integrator in the [Affiliate Keys](https://developer.sumup.com/affiliate-keys) page.
	"""

    foreign_transaction_id: str
    """
	Foreign transaction ID of the affiliate.
	It is a unique identifier for the transaction.
	It can be used later to fetch the transaction details via the [Transactions API](https://developer.sumup.com/api/transactions/get).
	"""

    key: str
    """
	Key of the affiliate.
	It is a unique identifier for the key  and should be generated by the integrator in the [Affiliate Keys](https://developer.sumup.com/affiliate-keys) page.
	"""

    tags: typing.Optional[CreateReaderCheckoutBodyAffiliateTags] = None
    """
	Additional metadata for the transaction.
	It is key-value object that can be associated with the transaction.
	"""


CreateReaderCheckoutBodyCardType = typing.Literal["credit", "debit"]


class CreateReaderCheckoutBodyTotalAmount(pydantic.BaseModel):
    """
            Amount structure.

    The amount is represented as an integer value altogether with the currency and the minor unit.

    For example, EUR 1.00 is represented as value 100 with minor unit of 2.
    """

    currency: str
    """
	Currency ISO 4217 code
	"""

    minor_unit: int
    """
	The minor units of the currency.
	It represents the number of decimals of the currency. For the currencies CLP, COP and HUF, the minor unit is0.
	Min: 0
	"""

    value: int
    """
	Integer value of the amount.
	Min: 0
	"""


class CreateReaderCheckoutBody(pydantic.BaseModel):
    """
    Reader Checkout
    """

    total_amount: CreateReaderCheckoutBodyTotalAmount
    """
	Amount structure.
	
	The amount is represented as an integer value altogether with the currency and the minor unit.
	
	For example, EUR 1.00 is represented as value 100 with minor unit of 2.
	"""

    affiliate: typing.Optional[CreateReaderCheckoutBodyAffiliate] = None
    """
	Affiliate metadata for the transaction.
	It is a field that allow for integrators to track the source of the transaction.
	"""

    card_type: typing.Optional[CreateReaderCheckoutBodyCardType] = None
    """
	The card type of the card used for the transaction.
	Is is required only for some countries (e.g: Brazil).
	"""

    description: typing.Optional[str] = None
    """
	Description of the checkout to be shown in the Merchant Sales
	"""

    installments: typing.Optional[int] = None
    """
	Number of installments for the transaction.
	It may vary according to the merchant country.
	For example, in Brazil, the maximum number of installments is 12.
	"""

    return_url: typing.Optional[str] = None
    """
	Webhook URL to which the payment result will be sent.
	It must be a HTTPS url.
	Format: uri
	"""

    tip_rates: typing.Optional[list[float]] = None
    """
	List of tipping rates to be displayed to the cardholder.
	The rates are in percentage and should be between 0.01 and 0.99.
	The list should be sorted in ascending order.
	"""

    tip_timeout: typing.Optional[int] = None
    """
	Time in seconds the cardholder has to select a tip rate.
	If not provided, the default value is 30 seconds.
	
	It can only be set if `tip_rates` is provided.
	
	**Note**: If the target device is a Solo, it must be in version 3.3.38.0 or higher.
	Default: 30
	
	Min: 30
	Max: 120
	"""


class ListReaders200Response(pydantic.BaseModel):
    """
    ListReaders200Response is a schema definition.
    """

    items: list[Reader]


class ReadersResource(Resource):
    def __init__(self, client: httpx.Client):
        super().__init__(client)

    def list(
        self, merchant_code: str, headers: typing.Optional[HeaderTypes] = None
    ) -> ListReaders200Response:
        """
        List Readers

        List all readers of the merchant.
        """
        resp = self._client.get(
            f"/v0.1/merchants/{merchant_code}/readers",
            headers=headers,
        )
        if resp.status_code == 200:
            return pydantic.TypeAdapter(ListReaders200Response).validate_python(resp.json())
        else:
            raise APIError("Unexpected response", status=resp.status_code, body=resp.text)

    def create(
        self,
        merchant_code: str,
        body: CreateReaderBody,
        headers: typing.Optional[HeaderTypes] = None,
    ) -> Reader:
        """
        Create a Reader

        Create a new Reader for the merchant account.
        """
        resp = self._client.post(
            f"/v0.1/merchants/{merchant_code}/readers",
            json=body.model_dump(),
            headers=headers,
        )
        if resp.status_code == 201:
            return pydantic.TypeAdapter(Reader).validate_python(resp.json())
        else:
            raise APIError("Unexpected response", status=resp.status_code, body=resp.text)

    def get(
        self, merchant_code: str, id: ReaderId, headers: typing.Optional[HeaderTypes] = None
    ) -> Reader:
        """
        Retrieve a Reader

        Retrieve a Reader.
        """
        resp = self._client.get(
            f"/v0.1/merchants/{merchant_code}/readers/{id}",
            headers=headers,
        )
        if resp.status_code == 200:
            return pydantic.TypeAdapter(Reader).validate_python(resp.json())
        elif resp.status_code == 404:
            raise APIError(
                "The requested Reader resource does not exists.",
                status=resp.status_code,
                body=resp.text,
            )
        else:
            raise APIError("Unexpected response", status=resp.status_code, body=resp.text)

    def delete_reader(
        self, merchant_code: str, id: ReaderId, headers: typing.Optional[HeaderTypes] = None
    ):
        """
        Delete a reader

        Delete a reader.
        """
        resp = self._client.delete(
            f"/v0.1/merchants/{merchant_code}/readers/{id}",
            headers=headers,
        )
        if resp.status_code == 200:
            return
        else:
            raise APIError("Unexpected response", status=resp.status_code, body=resp.text)

    def update(
        self,
        merchant_code: str,
        id: ReaderId,
        body: UpdateReaderBody,
        headers: typing.Optional[HeaderTypes] = None,
    ) -> Reader:
        """
        Update a Reader

        Update a Reader.
        """
        resp = self._client.patch(
            f"/v0.1/merchants/{merchant_code}/readers/{id}",
            json=body.model_dump(),
            headers=headers,
        )
        if resp.status_code == 200:
            return pydantic.TypeAdapter(Reader).validate_python(resp.json())
        elif resp.status_code == 403:
            raise APIError(
                "The reader is not linked to the merchant account.",
                status=resp.status_code,
                body=resp.text,
            )
        else:
            raise APIError("Unexpected response", status=resp.status_code, body=resp.text)

    def create_checkout(
        self,
        merchant_code: str,
        reader_id: str,
        body: CreateReaderCheckoutBody,
        headers: typing.Optional[HeaderTypes] = None,
    ) -> CreateReaderCheckoutResponse:
        """
        Create a Reader Checkout

        Creates a Checkout for a Reader.

        This process is asynchronous and the actual transaction may take some time to be stared on the device.


        There are some caveats when using this endpoint:
        * The target device must be online, otherwise checkout won't be accepted
        * After the checkout is accepted, the system has 60 seconds to start the payment on the target device. Duringthis time, any other checkout for the same device will be rejected.


        **Note**: If the target device is a Solo, it must be in version 3.3.24.3 or higher.
        """
        resp = self._client.post(
            f"/v0.1/merchants/{merchant_code}/readers/{reader_id}/checkout",
            json=body.model_dump(),
            headers=headers,
        )
        if resp.status_code == 201:
            return pydantic.TypeAdapter(CreateReaderCheckoutResponse).validate_python(resp.json())
        elif resp.status_code == 400:
            raise APIError(
                "Response when given params (or one of them) are invalid",
                status=resp.status_code,
                body=resp.text,
            )
        elif resp.status_code == 401:
            raise APIError("Unauthorized", status=resp.status_code, body=resp.text)
        elif resp.status_code == 422:
            raise APIError(
                "Response when given params (or one of them) are invalid",
                status=resp.status_code,
                body=resp.text,
            )
        elif resp.status_code == 500:
            raise APIError("Internal Server Error", status=resp.status_code, body=resp.text)
        elif resp.status_code == 502:
            raise APIError("Bad Gateway", status=resp.status_code, body=resp.text)
        elif resp.status_code == 504:
            raise APIError("Gateway Timeout", status=resp.status_code, body=resp.text)
        else:
            raise APIError("Unexpected response", status=resp.status_code, body=resp.text)

    def terminate_checkout(
        self, merchant_code: str, reader_id: str, headers: typing.Optional[HeaderTypes] = None
    ):
        """
        Terminate a Reader Checkout

        Terminate a Reader Checkout stops the current transaction on the target device.

        This process is asynchronous and the actual termination may take some time to be performed on the device.


        There are some caveats when using this endpoint:
        * The target device must be online, otherwise terminate won't be accepted
        * The action will succeed only if the device is waiting for cardholder action: e.g: waiting for card, waiting forPIN, etc.
        * There is no confirmation of the termination.

        If a transaction is successfully terminated and `return_url` was provided on Checkout, the transaction status willbe sent as `failed` to the provided URL.


        **Note**: If the target device is a Solo, it must be in version 3.3.28.0 or higher.
        """
        resp = self._client.post(
            f"/v0.1/merchants/{merchant_code}/readers/{reader_id}/terminate",
            headers=headers,
        )
        if resp.status_code == 202:
            return
        elif resp.status_code == 400:
            raise APIError(
                "Response when given params (or one of them) are invalid",
                status=resp.status_code,
                body=resp.text,
            )
        elif resp.status_code == 401:
            raise APIError("Unauthorized", status=resp.status_code, body=resp.text)
        elif resp.status_code == 422:
            raise APIError(
                "Response when given params (or one of them) are invalid",
                status=resp.status_code,
                body=resp.text,
            )
        elif resp.status_code == 500:
            raise APIError("Internal Server Error", status=resp.status_code, body=resp.text)
        elif resp.status_code == 502:
            raise APIError("Bad Gateway", status=resp.status_code, body=resp.text)
        elif resp.status_code == 504:
            raise APIError("Gateway Timeout", status=resp.status_code, body=resp.text)
        else:
            raise APIError("Unexpected response", status=resp.status_code, body=resp.text)


class AsyncReadersResource(AsyncResource):
    def __init__(self, client: httpx.AsyncClient):
        super().__init__(client)

    async def list(
        self, merchant_code: str, headers: typing.Optional[HeaderTypes] = None
    ) -> ListReaders200Response:
        """
        List Readers

        List all readers of the merchant.
        """
        resp = await self._client.get(
            f"/v0.1/merchants/{merchant_code}/readers",
            headers=headers,
        )
        if resp.status_code == 200:
            return pydantic.TypeAdapter(ListReaders200Response).validate_python(resp.json())
        else:
            raise APIError("Unexpected response", status=resp.status_code, body=resp.text)

    async def create(
        self,
        merchant_code: str,
        body: CreateReaderBody,
        headers: typing.Optional[HeaderTypes] = None,
    ) -> Reader:
        """
        Create a Reader

        Create a new Reader for the merchant account.
        """
        resp = await self._client.post(
            f"/v0.1/merchants/{merchant_code}/readers",
            json=body.model_dump(),
            headers=headers,
        )
        if resp.status_code == 201:
            return pydantic.TypeAdapter(Reader).validate_python(resp.json())
        else:
            raise APIError("Unexpected response", status=resp.status_code, body=resp.text)

    async def get(
        self, merchant_code: str, id: ReaderId, headers: typing.Optional[HeaderTypes] = None
    ) -> Reader:
        """
        Retrieve a Reader

        Retrieve a Reader.
        """
        resp = await self._client.get(
            f"/v0.1/merchants/{merchant_code}/readers/{id}",
            headers=headers,
        )
        if resp.status_code == 200:
            return pydantic.TypeAdapter(Reader).validate_python(resp.json())
        elif resp.status_code == 404:
            raise APIError(
                "The requested Reader resource does not exists.",
                status=resp.status_code,
                body=resp.text,
            )
        else:
            raise APIError("Unexpected response", status=resp.status_code, body=resp.text)

    async def delete_reader(
        self, merchant_code: str, id: ReaderId, headers: typing.Optional[HeaderTypes] = None
    ):
        """
        Delete a reader

        Delete a reader.
        """
        resp = await self._client.delete(
            f"/v0.1/merchants/{merchant_code}/readers/{id}",
            headers=headers,
        )
        if resp.status_code == 200:
            return
        else:
            raise APIError("Unexpected response", status=resp.status_code, body=resp.text)

    async def update(
        self,
        merchant_code: str,
        id: ReaderId,
        body: UpdateReaderBody,
        headers: typing.Optional[HeaderTypes] = None,
    ) -> Reader:
        """
        Update a Reader

        Update a Reader.
        """
        resp = await self._client.patch(
            f"/v0.1/merchants/{merchant_code}/readers/{id}",
            json=body.model_dump(),
            headers=headers,
        )
        if resp.status_code == 200:
            return pydantic.TypeAdapter(Reader).validate_python(resp.json())
        elif resp.status_code == 403:
            raise APIError(
                "The reader is not linked to the merchant account.",
                status=resp.status_code,
                body=resp.text,
            )
        else:
            raise APIError("Unexpected response", status=resp.status_code, body=resp.text)

    async def create_checkout(
        self,
        merchant_code: str,
        reader_id: str,
        body: CreateReaderCheckoutBody,
        headers: typing.Optional[HeaderTypes] = None,
    ) -> CreateReaderCheckoutResponse:
        """
        Create a Reader Checkout

        Creates a Checkout for a Reader.

        This process is asynchronous and the actual transaction may take some time to be stared on the device.


        There are some caveats when using this endpoint:
        * The target device must be online, otherwise checkout won't be accepted
        * After the checkout is accepted, the system has 60 seconds to start the payment on the target device. Duringthis time, any other checkout for the same device will be rejected.


        **Note**: If the target device is a Solo, it must be in version 3.3.24.3 or higher.
        """
        resp = await self._client.post(
            f"/v0.1/merchants/{merchant_code}/readers/{reader_id}/checkout",
            json=body.model_dump(),
            headers=headers,
        )
        if resp.status_code == 201:
            return pydantic.TypeAdapter(CreateReaderCheckoutResponse).validate_python(resp.json())
        elif resp.status_code == 400:
            raise APIError(
                "Response when given params (or one of them) are invalid",
                status=resp.status_code,
                body=resp.text,
            )
        elif resp.status_code == 401:
            raise APIError("Unauthorized", status=resp.status_code, body=resp.text)
        elif resp.status_code == 422:
            raise APIError(
                "Response when given params (or one of them) are invalid",
                status=resp.status_code,
                body=resp.text,
            )
        elif resp.status_code == 500:
            raise APIError("Internal Server Error", status=resp.status_code, body=resp.text)
        elif resp.status_code == 502:
            raise APIError("Bad Gateway", status=resp.status_code, body=resp.text)
        elif resp.status_code == 504:
            raise APIError("Gateway Timeout", status=resp.status_code, body=resp.text)
        else:
            raise APIError("Unexpected response", status=resp.status_code, body=resp.text)

    async def terminate_checkout(
        self, merchant_code: str, reader_id: str, headers: typing.Optional[HeaderTypes] = None
    ):
        """
        Terminate a Reader Checkout

        Terminate a Reader Checkout stops the current transaction on the target device.

        This process is asynchronous and the actual termination may take some time to be performed on the device.


        There are some caveats when using this endpoint:
        * The target device must be online, otherwise terminate won't be accepted
        * The action will succeed only if the device is waiting for cardholder action: e.g: waiting for card, waiting forPIN, etc.
        * There is no confirmation of the termination.

        If a transaction is successfully terminated and `return_url` was provided on Checkout, the transaction status willbe sent as `failed` to the provided URL.


        **Note**: If the target device is a Solo, it must be in version 3.3.28.0 or higher.
        """
        resp = await self._client.post(
            f"/v0.1/merchants/{merchant_code}/readers/{reader_id}/terminate",
            headers=headers,
        )
        if resp.status_code == 202:
            return
        elif resp.status_code == 400:
            raise APIError(
                "Response when given params (or one of them) are invalid",
                status=resp.status_code,
                body=resp.text,
            )
        elif resp.status_code == 401:
            raise APIError("Unauthorized", status=resp.status_code, body=resp.text)
        elif resp.status_code == 422:
            raise APIError(
                "Response when given params (or one of them) are invalid",
                status=resp.status_code,
                body=resp.text,
            )
        elif resp.status_code == 500:
            raise APIError("Internal Server Error", status=resp.status_code, body=resp.text)
        elif resp.status_code == 502:
            raise APIError("Bad Gateway", status=resp.status_code, body=resp.text)
        elif resp.status_code == 504:
            raise APIError("Gateway Timeout", status=resp.status_code, body=resp.text)
        else:
            raise APIError("Unexpected response", status=resp.status_code, body=resp.text)
