# Code generated by `py-sdk-gen`. DO NOT EDIT.
from .._service import Resource, AsyncResource, HeaderTypes
from .types import (
    Affiliate,
    CreateReaderCheckoutAmount,
    Meta,
    Reader,
    ReaderId,
    ReaderName,
    ReaderPairingCode,
)
import typing
import pydantic

CreateReaderCheckoutBodyCardType = typing.Literal["credit", "debit"]


class CreateReaderCheckoutBody(pydantic.BaseModel):
    """
    Reader Checkout
    """

    total_amount: CreateReaderCheckoutAmount
    """
	Amount of the transaction.
	The amount is represented as an integer value altogether with the currency and the minor unit.
	For example, EUR 1.00 is represented as value 100 with minor unit of 2.
	"""

    affiliate: typing.Optional[Affiliate] = None
    """
	Affiliate metadata for the transaction.
	It is an optional field that allow for integrators to track the source of the transaction.
	"""

    card_type: typing.Optional[CreateReaderCheckoutBodyCardType] = None
    """
	The card type of the card used for the transaction.
	Is is required only for some countries (e.g: Brazil).
	"""

    description: typing.Optional[str] = None
    """
	Description of the checkout to be shown in the Merchant Sales
	"""

    installments: typing.Optional[int] = None
    """
	Number of installments for the transaction.
	It may vary according to the merchant country.
	For example, in Brazil, the maximum number of installments is 12.
	"""

    return_url: typing.Optional[str] = None
    """
	Webhook URL to which the payment result will be sent.
	It must be a HTTPS url.
	Format: uri
	"""

    tip_rates: typing.Optional[list[float]] = None
    """
	List of tipping rates to be displayed to the cardholder.
	The rates are in percentage and should be between 0.01 and 0.99.
	The list should be sorted in ascending order.
	"""


class CreateReaderBody(pydantic.BaseModel):
    """
    CreateReaderBody is a schema definition.
    """

    pairing_code: ReaderPairingCode
    """
	The pairing code is a 8 or 9 character alphanumeric string that is displayed on a SumUp Device after initiatingthe pairing. It is used to link the physical device to the created pairing.
	Min length: 8
	Max length: 9
	"""

    meta: typing.Optional[Meta] = None
    """
	Set of user-defined key-value pairs attached to the object.
	Max properties: 50
	"""

    name: typing.Optional[ReaderName] = None
    """
	Custom human-readable, user-defined name for easier identification of the reader.
	Max length: 500
	"""


class UpdateReaderBody(pydantic.BaseModel):
    """
    UpdateReaderBody is a schema definition.
    """

    meta: typing.Optional[Meta] = None
    """
	Set of user-defined key-value pairs attached to the object.
	Max properties: 50
	"""

    name: typing.Optional[ReaderName] = None
    """
	Custom human-readable, user-defined name for easier identification of the reader.
	Max length: 500
	"""


class CreateReaderCheckout201ResponseData(pydantic.BaseModel):
    """
    CreateReaderCheckout201ResponseData is a schema definition.
    """

    client_transaction_id: typing.Optional[str] = None
    """
	The client transaction ID is a unique identifier for the transaction that is generated for the client.
	It can be used later to fetch the transaction details via the [Transactions API](https://developer.sumup.com/api/transactions/get).
	Format: uuid
	"""


class CreateReaderCheckout201Response(pydantic.BaseModel):
    """
    CreateReaderCheckout201Response is a schema definition.
    """

    data: typing.Optional[CreateReaderCheckout201ResponseData] = None


class ListReaders200Response(pydantic.BaseModel):
    """
    ListReaders200Response is a schema definition.
    """

    items: list[Reader]


class ReadersResource(Resource):
    def __init__(self, client):
        super().__init__(client)

    def create_checkout(
        self,
        merchant_code: str,
        id: str,
        body: CreateReaderCheckoutBody,
        headers: typing.Optional[HeaderTypes] = None,
    ) -> CreateReaderCheckout201Response:
        """
        Create a Reader Checkout

        Create a Checkout for a Reader.

        This process is asynchronous and the actual transaction may take some time to be stared on the device.


        There are some caveats when using this endpoint:
        * The target device must be online, otherwise checkout won't be accepted
        * After the checkout is accepted, the system has 60 seconds to start the payment on the target device. Duringthis time, any other checkout for the same device will be rejected.

        **Note**: If the target device is a Solo, it must be in version 3.3.24.3 or higher.
        """
        resp = self._client.post(
            f"/v0.1/merchants/{merchant_code}/readers/{id}/checkout",
            json=body,
            headers=headers,
        )
        return pydantic.TypeAdapter(CreateReaderCheckout201Response).validate_python(resp.json())

    def terminate_checkout(
        self, merchant_code: str, id: str, headers: typing.Optional[HeaderTypes] = None
    ):
        """
        Create a Reader Terminate action

        Create a Terminate action for a Reader.

        It stops the current transaction on the target device.

        This process is asynchronous and the actual termination may take some time to be performed on the device.


        There are some caveats when using this endpoint:
        * The target device must be online, otherwise terminate won't be accepted
        * The action will succeed only if the device is waiting for cardholder action: e.g: waiting for card, waiting forPIN, etc.
        * There is no confirmation of the termination.

        If a transaction is successfully terminated and `return_url` was provided on Checkout, the transaction status willbe sent as `failed` to the provided URL.

        **Note**: If the target device is a Solo, it must be in version 3.3.28.0 or higher.
        """
        self._client.post(
            f"/v0.1/merchants/{merchant_code}/readers/{id}/terminate",
            headers=headers,
        )

    def list(
        self, merchant_code: str, headers: typing.Optional[HeaderTypes] = None
    ) -> ListReaders200Response:
        """
        List Readers

        List all readers of the merchant.
        """
        resp = self._client.get(
            f"/v0.1/merchants/{merchant_code}/readers",
            headers=headers,
        )
        return pydantic.TypeAdapter(ListReaders200Response).validate_python(resp.json())

    def create(
        self,
        merchant_code: str,
        body: CreateReaderBody,
        headers: typing.Optional[HeaderTypes] = None,
    ) -> Reader:
        """
        Create a Reader

        Create a new Reader for the merchant account.
        """
        resp = self._client.post(
            f"/v0.1/merchants/{merchant_code}/readers",
            json=body,
            headers=headers,
        )
        return pydantic.TypeAdapter(Reader).validate_python(resp.json())

    def get(
        self, merchant_code: str, id: ReaderId, headers: typing.Optional[HeaderTypes] = None
    ) -> Reader:
        """
        Retrieve a Reader

        Retrieve a Reader.
        """
        resp = self._client.get(
            f"/v0.1/merchants/{merchant_code}/readers/{id}",
            headers=headers,
        )
        return pydantic.TypeAdapter(Reader).validate_python(resp.json())

    def delete_reader(
        self, merchant_code: str, id: ReaderId, headers: typing.Optional[HeaderTypes] = None
    ):
        """
        Delete a reader

        Delete a reader.
        """
        self._client.delete(
            f"/v0.1/merchants/{merchant_code}/readers/{id}",
            headers=headers,
        )

    def update(
        self,
        merchant_code: str,
        id: ReaderId,
        body: UpdateReaderBody,
        headers: typing.Optional[HeaderTypes] = None,
    ) -> Reader:
        """
        Update a Reader

        Update a Reader.
        """
        resp = self._client.patch(
            f"/v0.1/merchants/{merchant_code}/readers/{id}",
            json=body,
            headers=headers,
        )
        return pydantic.TypeAdapter(Reader).validate_python(resp.json())


class AsyncReadersResource(AsyncResource):
    def __init__(self, client):
        super().__init__(client)

    async def create_checkout(
        self,
        merchant_code: str,
        id: str,
        body: CreateReaderCheckoutBody,
        headers: typing.Optional[HeaderTypes] = None,
    ) -> CreateReaderCheckout201Response:
        """
        Create a Reader Checkout

        Create a Checkout for a Reader.

        This process is asynchronous and the actual transaction may take some time to be stared on the device.


        There are some caveats when using this endpoint:
        * The target device must be online, otherwise checkout won't be accepted
        * After the checkout is accepted, the system has 60 seconds to start the payment on the target device. Duringthis time, any other checkout for the same device will be rejected.

        **Note**: If the target device is a Solo, it must be in version 3.3.24.3 or higher.
        """
        resp = await self._client.post(
            f"/v0.1/merchants/{merchant_code}/readers/{id}/checkout",
            json=body,
            headers=headers,
        )
        return pydantic.TypeAdapter(CreateReaderCheckout201Response).validate_python(resp.json())

    async def terminate_checkout(
        self, merchant_code: str, id: str, headers: typing.Optional[HeaderTypes] = None
    ):
        """
        Create a Reader Terminate action

        Create a Terminate action for a Reader.

        It stops the current transaction on the target device.

        This process is asynchronous and the actual termination may take some time to be performed on the device.


        There are some caveats when using this endpoint:
        * The target device must be online, otherwise terminate won't be accepted
        * The action will succeed only if the device is waiting for cardholder action: e.g: waiting for card, waiting forPIN, etc.
        * There is no confirmation of the termination.

        If a transaction is successfully terminated and `return_url` was provided on Checkout, the transaction status willbe sent as `failed` to the provided URL.

        **Note**: If the target device is a Solo, it must be in version 3.3.28.0 or higher.
        """
        await self._client.post(
            f"/v0.1/merchants/{merchant_code}/readers/{id}/terminate",
            headers=headers,
        )

    async def list(
        self, merchant_code: str, headers: typing.Optional[HeaderTypes] = None
    ) -> ListReaders200Response:
        """
        List Readers

        List all readers of the merchant.
        """
        resp = await self._client.get(
            f"/v0.1/merchants/{merchant_code}/readers",
            headers=headers,
        )
        return pydantic.TypeAdapter(ListReaders200Response).validate_python(resp.json())

    async def create(
        self,
        merchant_code: str,
        body: CreateReaderBody,
        headers: typing.Optional[HeaderTypes] = None,
    ) -> Reader:
        """
        Create a Reader

        Create a new Reader for the merchant account.
        """
        resp = await self._client.post(
            f"/v0.1/merchants/{merchant_code}/readers",
            json=body,
            headers=headers,
        )
        return pydantic.TypeAdapter(Reader).validate_python(resp.json())

    async def get(
        self, merchant_code: str, id: ReaderId, headers: typing.Optional[HeaderTypes] = None
    ) -> Reader:
        """
        Retrieve a Reader

        Retrieve a Reader.
        """
        resp = await self._client.get(
            f"/v0.1/merchants/{merchant_code}/readers/{id}",
            headers=headers,
        )
        return pydantic.TypeAdapter(Reader).validate_python(resp.json())

    async def delete_reader(
        self, merchant_code: str, id: ReaderId, headers: typing.Optional[HeaderTypes] = None
    ):
        """
        Delete a reader

        Delete a reader.
        """
        await self._client.delete(
            f"/v0.1/merchants/{merchant_code}/readers/{id}",
            headers=headers,
        )

    async def update(
        self,
        merchant_code: str,
        id: ReaderId,
        body: UpdateReaderBody,
        headers: typing.Optional[HeaderTypes] = None,
    ) -> Reader:
        """
        Update a Reader

        Update a Reader.
        """
        resp = await self._client.patch(
            f"/v0.1/merchants/{merchant_code}/readers/{id}",
            json=body,
            headers=headers,
        )
        return pydantic.TypeAdapter(Reader).validate_python(resp.json())
