# Code generated by `py-sdk-gen`. DO NOT EDIT.
from .._service import Resource, AsyncResource, HeaderTypes
from .._exceptions import APIError
from .types import (
    CreateReaderCheckoutResponse,
    Metadata,
    Reader,
    ReaderId,
    ReaderName,
    ReaderPairingCode,
    StatusResponse,
)
import httpx
import typing
import pydantic


class CreateReaderBody(pydantic.BaseModel):
    """
    CreateReaderBody is a schema definition.
    """

    name: ReaderName
    """
	Custom human-readable, user-defined name for easier identification of the reader.
	Max length: 500
	"""

    pairing_code: ReaderPairingCode
    """
	The pairing code is a 8 or 9 character alphanumeric string that is displayed on a SumUp Device after initiatingthe pairing. It is used to link the physical device to the created pairing.
	Min length: 8
	Max length: 9
	"""

    metadata: typing.Optional[Metadata] = None
    """
	Set of user-defined key-value pairs attached to the object. Partial updates are not supported. When updating, alwayssubmit whole metadata. Maximum of 64 parameters are allowed in the object.
	Max properties: 64
	"""


class UpdateReaderBody(pydantic.BaseModel):
    """
    UpdateReaderBody is a schema definition.
    """

    metadata: typing.Optional[Metadata] = None
    """
	Set of user-defined key-value pairs attached to the object. Partial updates are not supported. When updating, alwayssubmit whole metadata. Maximum of 64 parameters are allowed in the object.
	Max properties: 64
	"""

    name: typing.Optional[ReaderName] = None
    """
	Custom human-readable, user-defined name for easier identification of the reader.
	Max length: 500
	"""


CreateReaderCheckoutBodyAffiliateTags = dict[typing.Any, typing.Any]
"""
Additional metadata for the transaction.
It is key-value object that can be associated with the transaction.
"""


class CreateReaderCheckoutBodyAffiliate(pydantic.BaseModel):
    """
            Affiliate metadata for the transaction.
    It is a field that allow for integrators to track the source of the transaction.
    """

    app_id: str
    """
	Application ID of the affiliate.
	It is a unique identifier for the application and should be set by the integrator in the [Affiliate Keys](https://developer.sumup.com/affiliate-keys) page.
	"""

    foreign_transaction_id: str
    """
	Foreign transaction ID of the affiliate.
	It is a unique identifier for the transaction.
	It can be used later to fetch the transaction details via the [Transactions API](https://developer.sumup.com/api/transactions/get).
	"""

    key: str
    """
	Key of the affiliate.
	It is a unique identifier for the key  and should be generated by the integrator in the [Affiliate Keys](https://developer.sumup.com/affiliate-keys) page.
	"""

    tags: typing.Optional[CreateReaderCheckoutBodyAffiliateTags] = None
    """
	Additional metadata for the transaction.
	It is key-value object that can be associated with the transaction.
	"""


CreateReaderCheckoutBodyCardType = typing.Literal["credit", "debit"]


class CreateReaderCheckoutBodyTotalAmount(pydantic.BaseModel):
    """
            Amount structure.

    The amount is represented as an integer value altogether with the currency and the minor unit.

    For example, EUR 1.00 is represented as value 100 with minor unit of 2.
    """

    currency: str
    """
	Currency ISO 4217 code
	"""

    minor_unit: int
    """
	The minor units of the currency.
	It represents the number of decimals of the currency. For the currencies CLP, COP and HUF, the minor unit is0.
	Min: 0
	"""

    value: int
    """
	Integer value of the amount.
	Min: 0
	"""


class CreateReaderCheckoutBody(pydantic.BaseModel):
    """
    Reader Checkout
    """

    total_amount: CreateReaderCheckoutBodyTotalAmount
    """
	Amount structure.
	
	The amount is represented as an integer value altogether with the currency and the minor unit.
	
	For example, EUR 1.00 is represented as value 100 with minor unit of 2.
	"""

    affiliate: typing.Optional[CreateReaderCheckoutBodyAffiliate] = None
    """
	Affiliate metadata for the transaction.
	It is a field that allow for integrators to track the source of the transaction.
	"""

    card_type: typing.Optional[CreateReaderCheckoutBodyCardType] = None
    """
	The card type of the card used for the transaction.
	Is is required only for some countries (e.g: Brazil).
	"""

    description: typing.Optional[str] = None
    """
	Description of the checkout to be shown in the Merchant Sales
	"""

    installments: typing.Optional[int] = None
    """
	Number of installments for the transaction.
	It may vary according to the merchant country.
	For example, in Brazil, the maximum number of installments is 12.
	
	Omit if the merchant country does support installments.
	Otherwise, the checkout will be rejected.
	Min: 1
	"""

    return_url: typing.Optional[str] = None
    """
	Webhook URL to which the payment result will be sent.
	It must be a HTTPS url.
	Format: uri
	"""

    tip_rates: typing.Optional[list[float]] = None
    """
	List of tipping rates to be displayed to the cardholder.
	The rates are in percentage and should be between 0.01 and 0.99.
	The list should be sorted in ascending order.
	"""

    tip_timeout: typing.Optional[int] = None
    """
	Time in seconds the cardholder has to select a tip rate.
	If not provided, the default value is 30 seconds.
	
	It can only be set if `tip_rates` is provided.
	
	**Note**: If the target device is a Solo, it must be in version 3.3.38.0 or higher.
	Default: 30
	
	Min: 30
	Max: 120
	"""


class ListReaders200Response(pydantic.BaseModel):
    """
    ListReaders200Response is a schema definition.
    """

    items: list[Reader]


class ReadersResource(Resource):
    def __init__(self, client: httpx.Client):
        super().__init__(client)

    def list(
        self, merchant_code: str, headers: typing.Optional[HeaderTypes] = None
    ) -> ListReaders200Response:
        """
        List Readers

        List all readers of the merchant.
        """
        resp = self._client.get(
            f"/v0.1/merchants/{merchant_code}/readers",
            headers=headers,
        )
        if resp.status_code == 200:
            return pydantic.TypeAdapter(ListReaders200Response).validate_python(resp.json())
        else:
            raise APIError("Unexpected response", status=resp.status_code, body=resp.text)

    def create(
        self,
        merchant_code: str,
        body: CreateReaderBody,
        headers: typing.Optional[HeaderTypes] = None,
    ) -> Reader:
        """
        Create a Reader

        Create a new Reader for the merchant account.
        """
        resp = self._client.post(
            f"/v0.1/merchants/{merchant_code}/readers",
            json=body.model_dump(exclude_unset=True),
            headers=headers,
        )
        if resp.status_code == 201:
            return pydantic.TypeAdapter(Reader).validate_python(resp.json())
        elif resp.status_code == 400:
            raise APIError("The request is invalid.", status=resp.status_code, body=resp.text)
        elif resp.status_code == 404:
            raise APIError(
                "There's no pending reader for the submitted pairing code.",
                status=resp.status_code,
                body=resp.text,
            )
        elif resp.status_code == 409:
            raise APIError(
                "The Reader is not in a pending state.", status=resp.status_code, body=resp.text
            )
        else:
            raise APIError("Unexpected response", status=resp.status_code, body=resp.text)

    def get(
        self, merchant_code: str, id: ReaderId, headers: typing.Optional[HeaderTypes] = None
    ) -> Reader:
        """
        Retrieve a Reader

        Retrieve a Reader.
        """
        resp = self._client.get(
            f"/v0.1/merchants/{merchant_code}/readers/{id}",
            headers=headers,
        )
        if resp.status_code == 200:
            return pydantic.TypeAdapter(Reader).validate_python(resp.json())
        elif resp.status_code == 404:
            raise APIError(
                "The requested Reader resource does not exists.",
                status=resp.status_code,
                body=resp.text,
            )
        else:
            raise APIError("Unexpected response", status=resp.status_code, body=resp.text)

    def delete(
        self, merchant_code: str, id: ReaderId, headers: typing.Optional[HeaderTypes] = None
    ):
        """
        Delete a reader

        Delete a reader.
        """
        resp = self._client.delete(
            f"/v0.1/merchants/{merchant_code}/readers/{id}",
            headers=headers,
        )
        if resp.status_code == 200:
            return
        elif resp.status_code == 404:
            raise APIError(
                "The requested Reader resource does not exists.",
                status=resp.status_code,
                body=resp.text,
            )
        else:
            raise APIError("Unexpected response", status=resp.status_code, body=resp.text)

    def update(
        self,
        merchant_code: str,
        id: ReaderId,
        body: UpdateReaderBody,
        headers: typing.Optional[HeaderTypes] = None,
    ) -> Reader:
        """
        Update a Reader

        Update a Reader.
        """
        resp = self._client.patch(
            f"/v0.1/merchants/{merchant_code}/readers/{id}",
            json=body.model_dump(exclude_unset=True),
            headers=headers,
        )
        if resp.status_code == 200:
            return pydantic.TypeAdapter(Reader).validate_python(resp.json())
        elif resp.status_code == 403:
            raise APIError(
                "The request isn't sufficiently authorized to modify the reader.",
                status=resp.status_code,
                body=resp.text,
            )
        elif resp.status_code == 404:
            raise APIError(
                "The requested Reader resource does not exists.",
                status=resp.status_code,
                body=resp.text,
            )
        else:
            raise APIError("Unexpected response", status=resp.status_code, body=resp.text)

    def create_checkout(
        self,
        merchant_code: str,
        reader_id: str,
        body: CreateReaderCheckoutBody,
        headers: typing.Optional[HeaderTypes] = None,
    ) -> CreateReaderCheckoutResponse:
        """
        Create a Reader Checkout

        Creates a Checkout for a Reader.

        This process is asynchronous and the actual transaction may take some time to be stared on the device.


        There are some caveats when using this endpoint:
        * The target device must be online, otherwise checkout won't be accepted
        * After the checkout is accepted, the system has 60 seconds to start the payment on the target device. Duringthis time, any other checkout for the same device will be rejected.


        **Note**: If the target device is a Solo, it must be in version 3.3.24.3 or higher.
        """
        resp = self._client.post(
            f"/v0.1/merchants/{merchant_code}/readers/{reader_id}/checkout",
            json=body.model_dump(exclude_unset=True),
            headers=headers,
        )
        if resp.status_code == 201:
            return pydantic.TypeAdapter(CreateReaderCheckoutResponse).validate_python(resp.json())
        elif resp.status_code == 400:
            raise APIError(
                "Response when given params (or one of them) are invalid",
                status=resp.status_code,
                body=resp.text,
            )
        elif resp.status_code == 401:
            raise APIError("Unauthorized", status=resp.status_code, body=resp.text)
        elif resp.status_code == 422:
            raise APIError(
                "Response when given params (or one of them) are invalid",
                status=resp.status_code,
                body=resp.text,
            )
        elif resp.status_code == 500:
            raise APIError("Internal Server Error", status=resp.status_code, body=resp.text)
        elif resp.status_code == 502:
            raise APIError("Bad Gateway", status=resp.status_code, body=resp.text)
        elif resp.status_code == 504:
            raise APIError("Gateway Timeout", status=resp.status_code, body=resp.text)
        else:
            raise APIError("Unexpected response", status=resp.status_code, body=resp.text)

    def get_status(
        self, merchant_code: str, reader_id: str, headers: typing.Optional[HeaderTypes] = None
    ) -> StatusResponse:
        """
        Get a Reader Status

        Provides the last known status for a Reader.

        This endpoint allows you to retrieve updates from the connected card reader, including the current screen beingdisplayed during the payment process and the device status (battery level, connectivity, and update state).

        Supported States

        * `IDLE` – Reader ready for next transaction
        * `SELECTING_TIP` – Waiting for tip input
        * `WAITING_FOR_CARD` – Awaiting card insert/tap
        * `WAITING_FOR_PIN` – Waiting for PIN entry
        * `WAITING_FOR_SIGNATURE` – Waiting for customer signature
        * `UPDATING_FIRMWARE` – Firmware update in progress

        Device Status

        * `ONLINE` – Device connected and operational
        * `OFFLINE` – Device disconnected (last state persisted)

        **Note**: If the target device is a Solo, it must be in version 3.3.39.0 or higher.
        """
        resp = self._client.get(
            f"/v0.1/merchants/{merchant_code}/readers/{reader_id}/status",
            headers=headers,
        )
        if resp.status_code == 200:
            return pydantic.TypeAdapter(StatusResponse).validate_python(resp.json())
        elif resp.status_code == 400:
            raise APIError(
                "Response when given params (or one of them) are invalid",
                status=resp.status_code,
                body=resp.text,
            )
        elif resp.status_code == 401:
            raise APIError(
                "Response when given merchant's token is invalid",
                status=resp.status_code,
                body=resp.text,
            )
        elif resp.status_code == 404:
            raise APIError(
                "Response when given reader is not found", status=resp.status_code, body=resp.text
            )
        elif resp.status_code == 500:
            raise APIError(
                "Generic error response for backend failure",
                status=resp.status_code,
                body=resp.text,
            )
        elif resp.status_code == 502:
            raise APIError(
                "Generic error response for an upstream service failure",
                status=resp.status_code,
                body=resp.text,
            )
        elif resp.status_code == 504:
            raise APIError(
                "Generic error response for an upstream service timeout",
                status=resp.status_code,
                body=resp.text,
            )
        else:
            raise APIError("Unexpected response", status=resp.status_code, body=resp.text)

    def terminate_checkout(
        self, merchant_code: str, reader_id: str, headers: typing.Optional[HeaderTypes] = None
    ):
        """
        Terminate a Reader Checkout

        Terminate a Reader Checkout stops the current transaction on the target device.

        This process is asynchronous and the actual termination may take some time to be performed on the device.


        There are some caveats when using this endpoint:
        * The target device must be online, otherwise terminate won't be accepted
        * The action will succeed only if the device is waiting for cardholder action: e.g: waiting for card, waiting forPIN, etc.
        * There is no confirmation of the termination.

        If a transaction is successfully terminated and `return_url` was provided on Checkout, the transaction status willbe sent as `failed` to the provided URL.


        **Note**: If the target device is a Solo, it must be in version 3.3.28.0 or higher.
        """
        resp = self._client.post(
            f"/v0.1/merchants/{merchant_code}/readers/{reader_id}/terminate",
            headers=headers,
        )
        if resp.status_code == 202:
            return
        elif resp.status_code == 400:
            raise APIError(
                "Response when given params (or one of them) are invalid",
                status=resp.status_code,
                body=resp.text,
            )
        elif resp.status_code == 401:
            raise APIError("Unauthorized", status=resp.status_code, body=resp.text)
        elif resp.status_code == 422:
            raise APIError(
                "Response when given params (or one of them) are invalid",
                status=resp.status_code,
                body=resp.text,
            )
        elif resp.status_code == 500:
            raise APIError("Internal Server Error", status=resp.status_code, body=resp.text)
        elif resp.status_code == 502:
            raise APIError("Bad Gateway", status=resp.status_code, body=resp.text)
        elif resp.status_code == 504:
            raise APIError("Gateway Timeout", status=resp.status_code, body=resp.text)
        else:
            raise APIError("Unexpected response", status=resp.status_code, body=resp.text)


class AsyncReadersResource(AsyncResource):
    def __init__(self, client: httpx.AsyncClient):
        super().__init__(client)

    async def list(
        self, merchant_code: str, headers: typing.Optional[HeaderTypes] = None
    ) -> ListReaders200Response:
        """
        List Readers

        List all readers of the merchant.
        """
        resp = await self._client.get(
            f"/v0.1/merchants/{merchant_code}/readers",
            headers=headers,
        )
        if resp.status_code == 200:
            return pydantic.TypeAdapter(ListReaders200Response).validate_python(resp.json())
        else:
            raise APIError("Unexpected response", status=resp.status_code, body=resp.text)

    async def create(
        self,
        merchant_code: str,
        body: CreateReaderBody,
        headers: typing.Optional[HeaderTypes] = None,
    ) -> Reader:
        """
        Create a Reader

        Create a new Reader for the merchant account.
        """
        resp = await self._client.post(
            f"/v0.1/merchants/{merchant_code}/readers",
            json=body.model_dump(exclude_unset=True),
            headers=headers,
        )
        if resp.status_code == 201:
            return pydantic.TypeAdapter(Reader).validate_python(resp.json())
        elif resp.status_code == 400:
            raise APIError("The request is invalid.", status=resp.status_code, body=resp.text)
        elif resp.status_code == 404:
            raise APIError(
                "There's no pending reader for the submitted pairing code.",
                status=resp.status_code,
                body=resp.text,
            )
        elif resp.status_code == 409:
            raise APIError(
                "The Reader is not in a pending state.", status=resp.status_code, body=resp.text
            )
        else:
            raise APIError("Unexpected response", status=resp.status_code, body=resp.text)

    async def get(
        self, merchant_code: str, id: ReaderId, headers: typing.Optional[HeaderTypes] = None
    ) -> Reader:
        """
        Retrieve a Reader

        Retrieve a Reader.
        """
        resp = await self._client.get(
            f"/v0.1/merchants/{merchant_code}/readers/{id}",
            headers=headers,
        )
        if resp.status_code == 200:
            return pydantic.TypeAdapter(Reader).validate_python(resp.json())
        elif resp.status_code == 404:
            raise APIError(
                "The requested Reader resource does not exists.",
                status=resp.status_code,
                body=resp.text,
            )
        else:
            raise APIError("Unexpected response", status=resp.status_code, body=resp.text)

    async def delete(
        self, merchant_code: str, id: ReaderId, headers: typing.Optional[HeaderTypes] = None
    ):
        """
        Delete a reader

        Delete a reader.
        """
        resp = await self._client.delete(
            f"/v0.1/merchants/{merchant_code}/readers/{id}",
            headers=headers,
        )
        if resp.status_code == 200:
            return
        elif resp.status_code == 404:
            raise APIError(
                "The requested Reader resource does not exists.",
                status=resp.status_code,
                body=resp.text,
            )
        else:
            raise APIError("Unexpected response", status=resp.status_code, body=resp.text)

    async def update(
        self,
        merchant_code: str,
        id: ReaderId,
        body: UpdateReaderBody,
        headers: typing.Optional[HeaderTypes] = None,
    ) -> Reader:
        """
        Update a Reader

        Update a Reader.
        """
        resp = await self._client.patch(
            f"/v0.1/merchants/{merchant_code}/readers/{id}",
            json=body.model_dump(exclude_unset=True),
            headers=headers,
        )
        if resp.status_code == 200:
            return pydantic.TypeAdapter(Reader).validate_python(resp.json())
        elif resp.status_code == 403:
            raise APIError(
                "The request isn't sufficiently authorized to modify the reader.",
                status=resp.status_code,
                body=resp.text,
            )
        elif resp.status_code == 404:
            raise APIError(
                "The requested Reader resource does not exists.",
                status=resp.status_code,
                body=resp.text,
            )
        else:
            raise APIError("Unexpected response", status=resp.status_code, body=resp.text)

    async def create_checkout(
        self,
        merchant_code: str,
        reader_id: str,
        body: CreateReaderCheckoutBody,
        headers: typing.Optional[HeaderTypes] = None,
    ) -> CreateReaderCheckoutResponse:
        """
        Create a Reader Checkout

        Creates a Checkout for a Reader.

        This process is asynchronous and the actual transaction may take some time to be stared on the device.


        There are some caveats when using this endpoint:
        * The target device must be online, otherwise checkout won't be accepted
        * After the checkout is accepted, the system has 60 seconds to start the payment on the target device. Duringthis time, any other checkout for the same device will be rejected.


        **Note**: If the target device is a Solo, it must be in version 3.3.24.3 or higher.
        """
        resp = await self._client.post(
            f"/v0.1/merchants/{merchant_code}/readers/{reader_id}/checkout",
            json=body.model_dump(exclude_unset=True),
            headers=headers,
        )
        if resp.status_code == 201:
            return pydantic.TypeAdapter(CreateReaderCheckoutResponse).validate_python(resp.json())
        elif resp.status_code == 400:
            raise APIError(
                "Response when given params (or one of them) are invalid",
                status=resp.status_code,
                body=resp.text,
            )
        elif resp.status_code == 401:
            raise APIError("Unauthorized", status=resp.status_code, body=resp.text)
        elif resp.status_code == 422:
            raise APIError(
                "Response when given params (or one of them) are invalid",
                status=resp.status_code,
                body=resp.text,
            )
        elif resp.status_code == 500:
            raise APIError("Internal Server Error", status=resp.status_code, body=resp.text)
        elif resp.status_code == 502:
            raise APIError("Bad Gateway", status=resp.status_code, body=resp.text)
        elif resp.status_code == 504:
            raise APIError("Gateway Timeout", status=resp.status_code, body=resp.text)
        else:
            raise APIError("Unexpected response", status=resp.status_code, body=resp.text)

    async def get_status(
        self, merchant_code: str, reader_id: str, headers: typing.Optional[HeaderTypes] = None
    ) -> StatusResponse:
        """
        Get a Reader Status

        Provides the last known status for a Reader.

        This endpoint allows you to retrieve updates from the connected card reader, including the current screen beingdisplayed during the payment process and the device status (battery level, connectivity, and update state).

        Supported States

        * `IDLE` – Reader ready for next transaction
        * `SELECTING_TIP` – Waiting for tip input
        * `WAITING_FOR_CARD` – Awaiting card insert/tap
        * `WAITING_FOR_PIN` – Waiting for PIN entry
        * `WAITING_FOR_SIGNATURE` – Waiting for customer signature
        * `UPDATING_FIRMWARE` – Firmware update in progress

        Device Status

        * `ONLINE` – Device connected and operational
        * `OFFLINE` – Device disconnected (last state persisted)

        **Note**: If the target device is a Solo, it must be in version 3.3.39.0 or higher.
        """
        resp = await self._client.get(
            f"/v0.1/merchants/{merchant_code}/readers/{reader_id}/status",
            headers=headers,
        )
        if resp.status_code == 200:
            return pydantic.TypeAdapter(StatusResponse).validate_python(resp.json())
        elif resp.status_code == 400:
            raise APIError(
                "Response when given params (or one of them) are invalid",
                status=resp.status_code,
                body=resp.text,
            )
        elif resp.status_code == 401:
            raise APIError(
                "Response when given merchant's token is invalid",
                status=resp.status_code,
                body=resp.text,
            )
        elif resp.status_code == 404:
            raise APIError(
                "Response when given reader is not found", status=resp.status_code, body=resp.text
            )
        elif resp.status_code == 500:
            raise APIError(
                "Generic error response for backend failure",
                status=resp.status_code,
                body=resp.text,
            )
        elif resp.status_code == 502:
            raise APIError(
                "Generic error response for an upstream service failure",
                status=resp.status_code,
                body=resp.text,
            )
        elif resp.status_code == 504:
            raise APIError(
                "Generic error response for an upstream service timeout",
                status=resp.status_code,
                body=resp.text,
            )
        else:
            raise APIError("Unexpected response", status=resp.status_code, body=resp.text)

    async def terminate_checkout(
        self, merchant_code: str, reader_id: str, headers: typing.Optional[HeaderTypes] = None
    ):
        """
        Terminate a Reader Checkout

        Terminate a Reader Checkout stops the current transaction on the target device.

        This process is asynchronous and the actual termination may take some time to be performed on the device.


        There are some caveats when using this endpoint:
        * The target device must be online, otherwise terminate won't be accepted
        * The action will succeed only if the device is waiting for cardholder action: e.g: waiting for card, waiting forPIN, etc.
        * There is no confirmation of the termination.

        If a transaction is successfully terminated and `return_url` was provided on Checkout, the transaction status willbe sent as `failed` to the provided URL.


        **Note**: If the target device is a Solo, it must be in version 3.3.28.0 or higher.
        """
        resp = await self._client.post(
            f"/v0.1/merchants/{merchant_code}/readers/{reader_id}/terminate",
            headers=headers,
        )
        if resp.status_code == 202:
            return
        elif resp.status_code == 400:
            raise APIError(
                "Response when given params (or one of them) are invalid",
                status=resp.status_code,
                body=resp.text,
            )
        elif resp.status_code == 401:
            raise APIError("Unauthorized", status=resp.status_code, body=resp.text)
        elif resp.status_code == 422:
            raise APIError(
                "Response when given params (or one of them) are invalid",
                status=resp.status_code,
                body=resp.text,
            )
        elif resp.status_code == 500:
            raise APIError("Internal Server Error", status=resp.status_code, body=resp.text)
        elif resp.status_code == 502:
            raise APIError("Bad Gateway", status=resp.status_code, body=resp.text)
        elif resp.status_code == 504:
            raise APIError("Gateway Timeout", status=resp.status_code, body=resp.text)
        else:
            raise APIError("Unexpected response", status=resp.status_code, body=resp.text)
