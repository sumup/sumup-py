# Code generated by `py-sdk-gen`. DO NOT EDIT.
import datetime
import typing
import pydantic

Metadata = dict[str, typing.Any]
"""
Set of user-defined key-value pairs attached to the object. Partial updates are not supported. When updating, alwayssubmit whole metadata. Maximum of 64 parameters are allowed in the object.
Max properties: 64
"""


class Role(pydantic.BaseModel):
    """
    A custom role that can be used to assign set of permissions to members.
    """

    created_at: datetime.datetime
    """
	The timestamp of when the role was created.
	"""

    id: str
    """
	Unique identifier of the role.
	"""

    is_predefined: bool
    """
	True if the role is provided by SumUp.
	"""

    name: str
    """
	User-defined name of the role.
	"""

    permissions: list[str]
    """
	List of permission granted by this role.
	Max items: 100
	"""

    updated_at: datetime.datetime
    """
	The timestamp of when the role was last updated.
	"""

    description: typing.Optional[str] = None
    """
	User-defined description of the role.
	"""

    metadata: typing.Optional[Metadata] = None
    """
	Set of user-defined key-value pairs attached to the object. Partial updates are not supported. When updating, alwayssubmit whole metadata. Maximum of 64 parameters are allowed in the object.
	Max properties: 64
	"""


class Problem(pydantic.BaseModel):
    """
            A RFC 9457 problem details object.

    Additional properties specific to the problem type may be present.
    """

    type: str
    """
	A URI reference that identifies the problem type.
	Format: uri
	"""

    detail: typing.Optional[str] = None
    """
	A human-readable explanation specific to this occurrence of the problem.
	"""

    instance: typing.Optional[str] = None
    """
	A URI reference that identifies the specific occurrence of the problem.
	Format: uri
	"""

    status: typing.Optional[int] = None
    """
	The HTTP status code generated by the origin server for this occurrence of the problem.
	"""

    title: typing.Optional[str] = None
    """
	A short, human-readable summary of the problem type.
	"""

    model_config = pydantic.ConfigDict(extra="allow")

    @pydantic.model_validator(mode="before")
    @classmethod
    def _merge_additional_properties(cls, values: typing.Any) -> typing.Any:
        if not isinstance(values, dict):
            return values

        additional = values.get("additional_properties")
        if not isinstance(additional, dict):
            return values

        merged = dict(additional)
        for key, value in values.items():
            if key != "additional_properties":
                merged[key] = value

        return merged

    @property
    def additional_properties(self) -> dict[str, typing.Any]:
        if self.model_extra is None:
            object.__setattr__(self, "__pydantic_extra__", {})
        return typing.cast(dict[str, typing.Any], self.model_extra)

    @additional_properties.setter
    def additional_properties(self, value: dict[str, typing.Any]) -> None:
        object.__setattr__(self, "__pydantic_extra__", dict(value))
